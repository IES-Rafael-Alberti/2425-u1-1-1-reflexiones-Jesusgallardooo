[![Review Assignment Due Date](https://classroom.github.com/assets/deadline-readme-button-22041afd0340ce965d47ae6ef1cefeee28c7c493a6346c4f15d667ab976d596c.svg)](https://classroom.github.com/a/Z6NE2ogx)
[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-2e0aaae1b6195c2367325f4f02e2d04e9abb55f0b24a779b69b11b9e10269abc.svg)](https://classroom.github.com/online_ide?assignment_repo_id=16551485&assignment_repo_type=AssignmentRepo)
# Práctica 1: Introducción al desarrollo. Reflexiones.

Apoyate en los siguientes recursos para realizar la práctica:

[Descripción de la práctica](https://revilofe.github.io/section3/u01/practica/EDES-U1.-Practica010/)


---

# P 1.10: Reflexión y discusión sobre los resultados¶

## Identificación de la Actividad
- **ID de la Actividad:** 1.10
- **Módulo:** EDES
- **Unidad de Trabajo:** U1: Introducción al desarrollo de software 
- **Fecha de Creación:** 15/10/2024
- **Fecha de Entrega:** 20/10/2024
- **Alumno(s):** 
  - **Nombre y Apellidos:** Jesús  Gallardo Domínguez
  - **Correo electrónico:** jgaldom0701@g.educaand.es
  - **Iniciales del Alumno/Grupo:** JGD

## Descripción de la Actividad
Respuesta a una serie de preguntas, concretamente 40 preguntas, las cuales buscan reforzar y conseguir que adquiramos los conocimientos vistos en clases de la unidad 1: Introducción al desarrollo de software. Tocando detalladamente todos y cada uno de los puntos vistos en la unidad.  

# Preguntas

## 1. Relación de software y hardware


### 1.1 Primera parte


#### 1.1.1. ¿Cómo se ejecuta el código en el procesador? 

Respuesta

#### 1.1.2. ¿Qué hace la memoria RAM con la información del botón o el LED? 

Respuesta

#### 1.1.3. ¿Cómo se comunican los periféricos (botón y LED) con el procesador? 

Respuesta

### 1.2 Segunda parte

Respuesta

#### 1.2.1. ¿Cómo interactúan el procesador, la memoria y los periféricos en la ejecución del programa? 

Respuesta

####  1.2.2. ¿Qué pasa con los datos en la memoria cuando el programa se ejecuta? 

Respuesta

####  1.2.3. ¿Qué roles juegan las instrucciones del software en esta interacción? 

Respuesta

####  1.2.4. ¿Cómo se relaciona esta simulación con lo que ocurre en un ordenador real? 

Respuesta

## 2. Del código fuente al ejecutable¶


#### 2.1. ¿Cómo se diferencia el código fuente del código objeto y del ejecutable? 

Respuesta

####  2.2. ¿Por qué el ordenador no puede entender el código fuente directamente? 

Respuesta

####  2.3. ¿Por qué es importante el paso de enlazado en la creación de programas? 

Respuesta

####  2.4. ¿Qué ocurre si falta alguna de las etapas (código objeto o ejecutable)? 

Respuesta

## 3. Generación de código intermedio

#### 3.1. ¿Cómo difiere el código intermedio del código ejecutable tradicional? 

Respuesta

####  3.2. ¿Por qué es útil tener una máquina virtual? 

Respuesta

####  3.3. ¿Qué ventajas ofrece el código intermedio? 

Respuesta

####  3.4. ¿Además de java, qué otros lenguajes usan máquinas virtuales? 

Respuesta

## 4. Lenguajes de programación


### 4.1 Primera parte


####  Compara el proceso de ejecución entre el lenguaje compilado y el interpretado. 


####   4.1.1. ¿Qué diferencias notaron en el proceso de compilación frente a la ejecución directa? 

Respuesta

####   4.1.2. ¿Qué pasa si hay un error de sintaxis en cada lenguaje? ¿Cuándo se detecta el error? 

Respuesta

### 4.2 Segunda parte


#### Compara un lenguaje de alto nivel con uno de bajo nivel.


#### 4.2.1. ¿Qué notaron sobre la abstracción entre los lenguajes de alto nivel y bajo nivel?

Respuesta

#### 4.2.2. ¿Qué ventajas y desventajas encontraron en cada uno?

Respuesta

### 4.3 Tercera parte



#### Compara un lenguaje orientado a objetos vs funcional.


#### 4.3.1. ¿Cómo funciona la organización de datos en Java usando objetos y métodos?

Respuesta

#### 4.3.2. ¿Cómo es diferente trabajar en un enfoque funcional en Python, usando solo funciones puras?      

Respuesta

### 4.4 Reflexión final

#### 4.4.1. ¿Qué lenguajes se sintieron más fáciles de usar? ¿Por qué?

Respuesta

#### 4.4.2. ¿En qué casos es preferible usar un lenguaje compilado frente a uno interpretado?

Respuesta

#### 4.4.3. ¿Cuándo es mejor usar un lenguaje de alto nivel en lugar de uno de bajo nivel?

Respuesta

#### 4.4.4. ¿Cómo se siente trabajar con el paradigma orientado a objetos en comparación con el imperativo o funcional?

Respuesta

## 5. Herramientas de desarrollo


### 5.1 Primera parte


#### Respecto a las proceso de creación de software identifica un conjunto de herramientas a usar.


#### 5.1.1. ¿Qué hace cada una de las herramientas?

Respuesta

#### 5.1.2. ¿Qué tipo de tareas facilita?

Respuesta

#### 5.1.3. ¿Qué características ofrece que la hacen única o diferente de otras herramientas similares?

Respuesta

#### 5.1.4. Elige una ¿Cómo es la experiencia de usuario al usarla? ¿Es fácil o compleja?

Respuesta

#### 5.1.5. Elige una ¿En qué situaciones sería ideal utilizar esta herramienta?

Respuesta

#### 5.1.6. Elige una ¿Qué limitaciones encontraste en la herramienta? 

Respuesta

### 5.2 Segunda parte


#### Céntrate en una herramienta dentro de la misma categoría y compárala con otras:


#### 5.2.1. ¿Qué herramienta se considera más útil y por qué?

Respuesta

#### 5.2.2. ¿Qué ventajas tiene una sobre la otra?ç

Respuesta

#### 5.2.3. ¿Cuál herramienta resultó ser la más intuitiva y por qué?

Respuesta

#### 5.2.4. ¿En qué casos se recomendaría usar un compilador en lugar de un intérprete?

Respuesta

#### 5.2.5. ¿Qué tipo de proyectos se beneficiarían más de un framework como Django?

Respuesta

### 5.3 Reflexión final


#### Con base en la experiencia de evaluación de las herramientas:


#### 5.3.1. ¿Cómo crees que impacta la elección de la herramienta en la calidad del software?

Respuesta

#### 5.3.2. ¿Qué características buscarías en una herramienta para facilitar tu flujo de trabajo?

Respuesta

#### 5.3.3. ¿Cómo cambió tu percepción de estas herramientas después de haberlas probado y evaluado? 

Respuesta

## Conclusiones
[Resumen de las conclusiones alcanzadas al desarrollar la actividad, las lecciones aprendidas, y posibles mejoras que se puedan implementar en futuras entregas.]

## Bibliografía


- https://revilofe.github.io/
